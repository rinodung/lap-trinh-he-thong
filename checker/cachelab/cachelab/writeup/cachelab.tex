\documentclass[11pt]{article}

\usepackage{times}


%% Page layout
\oddsidemargin 0pt
\evensidemargin 0pt
\textheight 600pt
\textwidth 469pt
\setlength{\parindent}{0em}
\setlength{\parskip}{1ex}

\begin{document}

\title{15-213/18-213, Fall 2012\\
Cache Lab: Understanding Cache Memories\\
Assigned: Tuesday, October 2, 2012\\ 
Due: Thursday, October 11, 11:59PM\\
Last Possible Time to Turn in: Sunday, October 14, 11:59PM
}

\author{}
\date{}

\maketitle

\section{Logistics}
This is an individual project. All handins are electronic. 

\begin{quote}
{\bf SITE-SPECIFIC: Insert any other logistical items here, such as how to ask for help.}
\end{quote}


\section{Overview}
This lab will help you understand the impact that cache memories can
have on the performance of your C programs.

The lab consists of two parts. In the first part you will write a
small C program (about 200-300 lines) that simulates the behavior of a
cache memory.  In the second part, you will optimize a small matrix
transpose function, with the goal of minimizing the number of cache
misses.

\section{Downloading the assignment}

\begin{quote}
{\bf SITE-SPECIFIC: Insert a paragraph here that explains how the
instructor will hand out the {\tt cachelab-handout.tar} file to the
students.}
\end{quote}

Start by copying {\tt cachelab-handout.tar} to a protected Linux directory
in which you plan to do your work.  Then give the command
\begin{verbatim}
    linux> tar xvf cachelab-handout.tar
\end{verbatim}
This will create a directory called {\tt cachelab-handout} that
contains a number of files.  You will be modifying two
files: {\tt csim.c} and {\tt trans.c}.  To compile these files, type:
\begin{verbatim}
    linux> make clean
    linux> make
\end{verbatim}

\textbf{WARNING:} Do not let the Windows WinZip program open up your
       {\tt .tar} file (many Web browsers are set to do this
       automatically).  Instead, save the file to your Linux directory
       and use the Linux {\tt tar} program to extract the files.  In
       general, for this class you should NEVER use any platform other
       than Linux to modify your files. Doing so can cause loss of
       data (and important work!).

\section{Description}
The lab has two parts. In Part A you will implement a cache
simulator. In Part B you will write a matrix transpose function that
is optimized for cache performance.

\subsection{Reference Trace Files}

The {\tt traces} subdirectory of the handout directory contains a
collection of {\em reference trace files} that we will use to evaluate the correctness
of the cache simulator you write in Part A. 
The trace files are generated by a Linux program called {\tt
  valgrind}.  For example, typing
\begin{verbatim}
    linux> valgrind --log-fd=1 --tool=lackey -v --trace-mem=yes ls -l
\end{verbatim}
on the command line runs the executable program ``{\tt ls -l}'',
captures a trace of each of its memory accesses in the order they
occur, and prints them on \texttt{stdout}.  

{\tt Valgrind} memory traces have the following form:
\begin{verbatim}
I 0400d7d4,8
 M 0421c7f0,4
 L 04f6b868,8
 S 7ff0005c8,8
\end{verbatim}
Each line denotes one or two memory accesses. The format of each line is 
\begin{verbatim}
[space]operation address,size
\end{verbatim}
The {\em operation} field denotes the type of memory access: ``I''
  denotes an instruction load, ``L'' a data load, ``S''
  a data store, and ``M'' a data modify (i.e., a data load
  followed by a data store).  There is never a space before each ``I''.
  There is always a space before each ``M'', ``L'', and ``S''.
The {\em address} field specifies a 64-bit hexadecimal memory address. 
The {\em size} field specifies the number of bytes accessed by the
operation.


\subsection{Part A: Writing a Cache Simulator} 

In Part A you will write a cache simulator in {\tt csim.c} that takes
a {\tt valgrind} memory trace as input, simulates the hit/miss
behavior of a cache memory on this trace, and outputs the total number
of hits, misses, and evictions.

We have provided you with the binary executable of a {\em reference
  cache simulator}, called \verb+csim-ref+, that simulates the
behavior of a cache with arbitrary size and associativity on a {\tt
  valgrind} trace file.  It uses the LRU (least-recently used)
replacement policy when choosing which cache line to evict.

The reference simulator takes the following command-line arguments:
\begin{verbatim}
Usage: ./csim-ref [-hv] -s <s> -E <E> -b <b> -t <tracefile>
\end{verbatim}
\begin{itemize}
\item    {\tt -h}: Optional help flag that prints usage info
\item    {\tt -v}: Optional verbose flag that displays trace info
\item     {\tt -s <s>}: Number of set index bits ($S = 2^s$ is the number of sets)
\item    {\tt -E <E>}: Associativity (number of lines per set)
\item     {\tt -b <b>}: Number of block bits ($B = 2^b$ is the block size)
\item     {\tt -t <tracefile>}: Name of the {\tt valgrind} trace to replay
\end{itemize}
The command-line arguments are based on the notation ($s$, $E$, and
$b$) from page 597 of the CS:APP2e textbook. For example:
\begin{verbatim}
    linux> ./csim-ref -s 4 -E 1 -b 4 -t traces/yi.trace
    hits:4 misses:5 evictions:3
\end{verbatim}
The same example in verbose mode:
\begin{verbatim}
    linux> ./csim-ref -v -s 4 -E 1 -b 4 -t traces/yi.trace
    L 10,1 miss 
    M 20,1 miss hit 
    L 22,1 hit 
    S 18,1 hit 
    L 110,1 miss eviction 
    L 210,1 miss eviction 
    M 12,1 miss eviction hit 
    hits:4 misses:5 evictions:3
\end{verbatim}

Your job for Part A is to fill in the {\tt csim.c} file so that
it takes the same command line arguments and produces the identical
output as the reference simulator. Notice that this file is almost
completely empty. You'll need to write it from scratch.

\subsection*{Programming Rules for Part A}

\begin{itemize}
\item Include your name and loginID in the header comment for {\tt csim.c}.

\item Your {\tt csim.c} file must compile without warnings in order
  to receive credit.

\item Your simulator must work correctly for arbitrary $s$, $E$, and
  $b$. This means that you will need to allocate storage for your
  simulator's data structures using the \verb:malloc: function. Type ``man
  malloc'' for information about this function. 

\item For this lab, we are interested only in data cache performance,
  so your simulator should ignore all instruction cache accesses
  (lines starting with ``I''). Recall that {\tt valgrind} always puts
  ``I'' in the first column (with no preceding space), and ``M'',
  ``L'', and ``S'' in the second column (with a preceding space). This
  may help you parse the trace.

\item To receive credit for Part A,
  you must call the function {\tt printSummary}, with the total number
  of hits, misses, and evictions, at the end of your {\tt main}
  function:
\begin{verbatim}
    printSummary(hit_count, miss_count, eviction_count);
\end{verbatim}

\item For this this lab, you should assume that memory
  accesses are aligned properly, such that a single memory access
  never crosses block boundaries. By making this assumption, you can
  ignore the request sizes in the {\tt valgrind} traces.

\end{itemize}

\subsection{Part B: Optimizing Matrix Transpose}
In Part B you will write a transpose function in {\tt trans.c} that
causes as few cache misses as possible.

Let $A$ denote a matrix, and $A_{ij}$ denote the component on the ith
row and jth column. The {\em transpose} of $A$, denoted $A^T$, is a matrix
such that $A_{ij}=A^T_{ji}$.

To help you get started, we have given you an example
transpose function in {\tt trans.c} that
computes the transpose of $N \times M$ matrix $A$ and stores the
results in $M \times N$ matrix $B$:
\begin{verbatim}
    char trans_desc[] = "Simple row-wise scan transpose";
    void trans(int M, int N, int A[N][M], int B[M][N])
\end{verbatim}
The example transpose function is correct, but it is inefficient
because the access pattern results in relatively many cache misses.

Your job in Part B is to write a similar function, called
\verb+transpose_submit+, that minimizes the number of cache misses
across different sized matrices:
\begin{verbatim}
    char transpose_submit_desc[] = "Transpose submission";
    void transpose_submit(int M, int N, int A[N][M], int B[M][N]);
\end{verbatim}
Do {\em not} change the description string
(``\verb:Transpose submission:'') for your \verb:transpose_submit:
function.  The autograder searches for this string to determine which
transpose function to evaluate for credit.


\subsection*{Programming Rules for Part B}
\begin{itemize}
\item Include your name and loginID in the header comment for {\tt trans.c}.

\item Your code in {\tt trans.c} must compile without warnings to
  receive credit.

\item You are allowed to define at most 12 local variables of type
  \verb:int: per transpose function.\footnote{The reason for this
  restriction is that our testing code is not able to count references
  to the stack. We want you to limit your references to the stack and
  focus on the access patterns of the source and destination arrays.}

\item You are not allowed to side-step the previous rule by using any
  variables of type \verb:long: or by using any bit tricks to store more
  than one value to a single variable.

\item Your transpose function may not use recursion.

\item If you choose to use helper functions, you may not have more than 12
 local variables on the stack at a time between your helper functions and
 your top level transpose function. For example, if your transpose
 declares 8 variables, and then you call a function which uses 4
 variables, which calls another function which uses 2, you will have 
 14 variables on the stack, and you will be in violation of the rule.

\item Your transpose function may not modify array A. You may, however,
 do whatever you want with the contents of array B.

\item You are NOT allowed to define any arrays in your code or to use
  any variant of {\tt malloc}.

\end{itemize}

\section{Evaluation}
\label{sec:eval}
This section describes how your work will be evaluated. The full score
for this lab is 60 points:
\begin{itemize}
\item Part A: 27 Points 
\item Part B: 26 Points
\item Style: 7 Points
\end{itemize}

\subsection{Evaluation for Part A}
For Part A, we will run your cache simulator using different cache
parameters and traces.  There are eight test cases, each worth 3
points, except for the last case, which is worth 6 points:
\begin{verbatim}
  linux> ./csim -s 1 -E 1 -b 1 -t traces/yi2.trace
  linux> ./csim -s 4 -E 2 -b 4 -t traces/yi.trace
  linux> ./csim -s 2 -E 1 -b 4 -t traces/dave.trace
  linux> ./csim -s 2 -E 1 -b 3 -t traces/trans.trace
  linux> ./csim -s 2 -E 2 -b 3 -t traces/trans.trace
  linux> ./csim -s 2 -E 4 -b 3 -t traces/trans.trace
  linux> ./csim -s 5 -E 1 -b 5 -t traces/trans.trace
  linux> ./csim -s 5 -E 1 -b 5 -t traces/long.trace
\end{verbatim}
You can use the reference simulator \verb:csim-ref: to obtain the
correct answer for each of these test cases.  During debugging, use
the {\tt -v} option for a detailed record of each hit and miss.

For each test case, outputting the correct number of cache hits,
misses and evictions will give you full credit for that test case.
Each of your reported number of hits, misses and evictions is worth
1/3 of the credit for that test case.  That is, if a particular test
case is worth 3 points, and your simulator outputs the correct number
of hits and misses, but reports the wrong number of evictions, then
you will earn 2 points.

\subsection{Evaluation for Part B} 

For Part B, we will evaluate the correctness and performance of your
 \verb:transpose_submit: function on three different-sized output matrices:
\begin{itemize}
\item $32 \times 32$ ($M=32$, $N=32$)
\item $64 \times 64$ ($M=64$, $N=64$)
\item $61 \times 67$ ($M=61$, $N=67$) 
\end{itemize}


\subsubsection{Performance (26 pts)}


For each matrix size, the performance of your \verb:transpose_submit:
function is evaluated by using {\tt valgrind} to extract the address
trace for your function, and then using the reference simulator to
replay this trace on a cache with parameters ($s=5$, $E=1$, $b=5$).

Your performance score for each matrix size scales linearly with the
 number of misses, $m$, up to some threshold:

\begin{itemize}
\item $32 \times 32$: 8 points if $m < 300$, 0 points if $m > 600$
\item $64 \times 64$: 8 points if $m < 1,300$, 0 points if $m > 2,000$
\item $61 \times 67$: 10 points if $m < 2,000$, 0 points if $m > 3,000$
\end{itemize}

Your code must be correct to receive any performance points for a particular size.
Your code only needs to be correct for these three cases and you can
optimize it specifically for these three cases. In particular, it is
perfectly OK for your function to explicitly check for the input sizes
and implement separate code optimized for each case.


\subsection{Evaluation for Style}
There are 7 points for coding style. These will be assigned manually
by the course staff.  Style guidelines can be found on the course
website.

The course staff will inspect your code in Part B for illegal arrays
and excessive local variables.

\section{Working on the Lab}

\subsection{Working on Part A}
We have provided you with an autograding program, called
\verb:test-csim:, that tests the correctness of your cache simulator
on the reference traces. Be sure to compile your simulator before
running the test:
{\small
\begin{verbatim}
linux> make
linux> ./test-csim
                        Your simulator     Reference simulator
Points (s,E,b)    Hits  Misses  Evicts    Hits  Misses  Evicts
     3 (1,1,1)       9       8       6       9       8       6  traces/yi2.trace
     3 (4,2,4)       4       5       2       4       5       2  traces/yi.trace
     3 (2,1,4)       2       3       1       2       3       1  traces/dave.trace
     3 (2,1,3)     167      71      67     167      71      67  traces/trans.trace
     3 (2,2,3)     201      37      29     201      37      29  traces/trans.trace
     3 (2,4,3)     212      26      10     212      26      10  traces/trans.trace
     3 (5,1,5)     231       7       0     231       7       0  traces/trans.trace
     6 (5,1,5)  265189   21775   21743  265189   21775   21743  traces/long.trace
    27
\end{verbatim}
} 

For each test, it shows the number of points you earned, the cache
parameters, the input trace file, and a comparison of the results from
your simulator and the reference simulator.

Here are some hints and suggestions for working on Part A:
\begin{itemize}
\item Do your initial debugging on the small traces, such as
  \verb:traces/dave.trace:.

\item The reference simulator takes an optional \texttt{-v} argument
  that enables verbose output, displaying the hits, misses, and
  evictions that occur as a result of each memory access. You are
  not required to implement this feature in your {\tt csim.c} code,
  but we strongly recommend that you do so.  It will help you debug by
  allowing you to directly compare the behavior of your simulator with
  the reference simulator on the reference trace files.

\item We recommend that you use the {\tt getopt} function to parse
  your command line arguments. You'll need the following header files:
\begin{verbatim}
    #include <getopt.h> 
    #include <stdlib.h> 
    #include <unistd.h>	
\end{verbatim}
See ``{\tt man 3 getopt}'' for details. 

\item Each data load (L) or store (S) operation can cause at most one
  cache miss.  The data modify operation (M) is treated as a load
  followed by a store to the same address. Thus, an M operation can
  result in two cache hits, or a miss and a hit plus a possible
  eviction.

\item If you would like to use C0-style contracts from 15-122, you can
  include \verb+contracts.h+, which we have provided in the handout
  directory for your convenience.

\end{itemize}

\subsection{Working on Part B}
We have provided you with an autograding program, called {\tt
  test-trans.c}, that tests the correctness and performance of each of
the transpose functions that you have registered with the autograder. 

You can register up to 100 versions of the transpose function in your
{\tt  trans.c} file. Each transpose version has the following form:
\begin{verbatim}
    /* Header comment */
    char trans_simple_desc[] = "A simple transpose";
    void trans_simple(int M, int N, int A[N][M], int B[M][N])
    {
        /* your transpose code here */
    }
\end{verbatim}
Register a particular transpose function with the autograder by making
a call of the form:
\begin{verbatim}
    registerTransFunction(trans_simple, trans_simple_desc);
\end{verbatim}
in the {\tt registerFunctions} routine in {\tt trans.c}. At runtime,
the autograder will evaluate each registered transpose function and
print the results. Of course, one of the registered functions must be
the \verb:transpose_submit: function that you are submitting for
credit:
\begin{verbatim}
    registerTransFunction(transpose_submit, transpose_submit_desc);
\end{verbatim}
See the default {\tt trans.c} function for an example of how this works. 

The autograder takes the matrix size as input. It uses {\tt valgrind}
to generate a trace of each registered transpose function.  It then
evaluates each trace by running the reference simulator on a cache
with parameters ($s=5$, $E=1$, $b=5$).

For example, to test your registered transpose functions on a $32
\times 32$ matrix, rebuild \verb:test-trans:, and then run it with the 
appropriate values for $M$ and $N$:
{\small
\begin{verbatim}
linux> make
linux> ./test-trans -M 32 -N 32
Step 1: Evaluating registered transpose funcs for correctness:
func 0 (Transpose submission): correctness: 1
func 1 (Simple row-wise scan transpose): correctness: 1
func 2 (column-wise scan transpose): correctness: 1
func 3 (using a zig-zag access pattern): correctness: 1

Step 2: Generating memory traces for registered transpose funcs.

Step 3: Evaluating performance of registered transpose funcs (s=5, E=1, b=5)
func 0 (Transpose submission): hits:1766, misses:287, evictions:255
func 1 (Simple row-wise scan transpose): hits:870, misses:1183, evictions:1151
func 2 (column-wise scan transpose): hits:870, misses:1183, evictions:1151
func 3 (using a zig-zag access pattern): hits:1076, misses:977, evictions:945

Summary for official submission (func 0): correctness=1 misses=287
\end{verbatim}
} 

In this example, we have registered four different transpose
functions in {\tt trans.c}. The \verb:test-trans: program tests each
of the registered functions, displays the results for each, and
extracts the results for the official submission.

Here are some hints and suggestions for working on Part B.
\begin{itemize}
\item The {\tt test-trans} program saves the trace for function $i$ in
  file {\tt trace.f}$i$.\footnote{Because {\tt valgrind} introduces
    many stack accesses that have nothing to do with your code, we
    have filtered out all stack accesses from the trace. This is why
    we have banned local arrays and placed limits on the number of
    local variables.} These trace files are invaluable debugging tools
  that can help you understand exactly where the hits and misses for
  each transpose function are coming from. To debug a particular
  function, simply run its trace through the reference simulator with
  the verbose option:
\begin{verbatim}
linux> ./csim-ref -v -s 5 -E 1 -b 5 -t trace.f0
S 68312c,1 miss 
L 683140,8 miss 
L 683124,4 hit 
L 683120,4 hit 
L 603124,4 miss eviction 
S 6431a0,4 miss 
...
\end{verbatim}

\item Since your transpose function is being evaluated on a
  direct-mapped cache, conflict misses are a potential problem.  Think
  about the potential for conflict misses in your code, especially
  along the diagonal. Try to think of access patterns that will
  decrease the number of these conflict misses.

\item Blocking is a useful technique for reducing cache misses. See  
\begin{verbatim}
    http://csapp.cs.cmu.edu/public/waside/waside-blocking.pdf
\end{verbatim}
for more information.

\end{itemize}

\subsection{Putting it all Together}

We have provided you with a {\em driver program}, called
\verb+./driver.py+, that performs a complete evaluation of your
simulator and transpose code. This is the same program your instructor
uses to evaluate your handins. The driver uses {\tt test-csim}
to evaluate your simulator, and it uses {\tt test-trans} to evaluate
your submitted transpose function on the three matrix sizes. Then it
prints a summary of your results and the points you have earned. 

To run the driver, type:
\begin{verbatim}
    linux> ./driver.py
\end{verbatim}


\section{Handing in Your Work}
Each time you type {\tt make} in the \verb:cachelab-handout: directory,
  the Makefile creates a tarball, called {\tt userid-handin.tar},
  that contains your current {\tt csim.c} and {\tt trans.c} files.

\begin{quote}
{\bf SITE-SPECIFIC: Insert text here that tells each student how to
hand in their {\tt  userid\-handin.tar} file at your school.}
\end{quote}

{\bf IMPORTANT:} Do not create the handin tarball on a Windows or Mac machine,
and do not handin files in any other archive format, such as {\tt
  .zip}, {\tt .gzip}, or {\tt .tgz} files.

\end{document}
