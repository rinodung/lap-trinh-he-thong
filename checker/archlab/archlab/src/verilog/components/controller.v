// --------------------------------------------------------------------
// This part of the code was generated by including the file "controller.v"
// --------------------------------------------------------------------

// A simple controller to operate the Y86-64 processor.
// It would not be part of the actual hardware design, and 
// It operates by first downloading the bytes generated by assembling a .ys program.
// Then it resets the processor and enters RUN mode.
// The processor runs until an exception condition is reached (halt or error), or the cycle limit is exceeded.
// Then it uploads and prints status information, including the registers, the PC, the condition
// codes and the status.

// The tag INSERT-CODE-HERE (but with underscores rather than dashes)
//  indicates where the object code bytes should be inserted.

// Clock generator.  It alternates between 1 and 0 every five time units.
module cgen(clock);
   output clock;
   reg 	  clock;

   initial clock = 0;
   always
     #5 clock = ~clock;
endmodule

// Memory used to hold the object code that will be downloaded
module memory(wenable, waddr, wdata, renable, raddr, rdata, clock);
   parameter memsize = 4096; // Number of bytes in memory
   input         wenable;  // Write enable
   input  [63:0] waddr;    // Write address
   input  [63:0] wdata;    // Write data
   input 	 renable;  // Read enable
   input  [63:0] raddr;    // Read address
   output [63:0] rdata;    // Read data
   input 	 clock;

   reg    [ 7:0] mem [memsize-1:0];  // Byte addressable memory

   wire   [ 7:0] db0, db1, db2, db3, db4, db5, db6, db7; // Data bytes
   
   // Get the bytes of data;
   assign 	 db0 = renable ? mem[  raddr] : 0;
   assign 	 db1 = renable ? mem[raddr+1] : 0;
   assign 	 db2 = renable ? mem[raddr+2] : 0;
   assign 	 db3 = renable ? mem[raddr+3] : 0;
   assign 	 db4 = renable ? mem[raddr+4] : 0;
   assign 	 db5 = renable ? mem[raddr+5] : 0;
   assign 	 db6 = renable ? mem[raddr+6] : 0;
   assign 	 db7 = renable ? mem[raddr+7] : 0;
   assign 	 rdata[ 7: 0] = db0;
   assign 	 rdata[15: 8] = db1;
   assign 	 rdata[23:16] = db2;
   assign 	 rdata[31:24] = db3;
   assign 	 rdata[39:32] = db4;
   assign 	 rdata[47:40] = db5;
   assign 	 rdata[55:48] = db6;
   assign 	 rdata[63:56] = db7;

   // Write operation
   always
     @(posedge clock)
     begin
	if (renable)
	  begin
//	     $display("Code memory: Read 0x%x from 0x%x", rdata, raddr);
	  end
	if (wenable)
	  begin
             mem[waddr]   <= wdata[ 7: 0]; mem[waddr+1] <= wdata[15: 8];
             mem[waddr+2] <= wdata[23:16]; mem[waddr+3] <= wdata[31:24];
             mem[waddr+4] <= wdata[39:32]; mem[waddr+5] <= wdata[47:40];
             mem[waddr+6] <= wdata[55:48]; mem[waddr+7] <= wdata[63:56];
	  end
     end

   // Initialization
   integer i;
   initial
     begin
	for (i = 0; i < memsize; i = i+1)
          mem[i] = 0;
	// Program bytes
	// --------------------------------------------------------------------
	// The following initialization of the mem array is created by running the yas assembler
	// on a y86 assembly program with the "-V" option enabled.
	// --------------------------------------------------------------------
	// INSERT_CODE_HERE
	// --------------------------------------------------------------------
	// End of automatically generated initialization of mem array
	// --------------------------------------------------------------------
     end
endmodule

// The controller for operating the processor
module controller(mode, udaddr, idata, odata, stat, clock, max_cycles);
   parameter code_size = 2048;  // Max. code size

   output [ 2:0] mode;   // Signal operating mode to processor
   output [63:0] udaddr; // Upload/download address
   output [63:0] idata;  // Download data word
   input  [63:0] odata;  // Upload data word
   input  [ 2:0] 	 stat; // Exception status
   input 	 clock;          // Clock input
   input  [63:0] max_cycles; // Runtime cycle limit

   reg    [ 2:0] mode;
   reg    [63:0] udaddr;

   reg [63:0] 	 cycle_count;  // Used to limit duration of operation

   // Define modes
   parameter 	 RUN_MODE = 0;
   parameter 	 RESET_MODE = 1;    // Resetting processor;
   parameter 	 DOWNLOAD_MODE = 2; // Transfering to memory
   parameter 	 UPLOAD_MODE = 3;   // Reading from memory
   parameter 	 STATUS_MODE = 4;   // Uploading register & other status information
   parameter 	 DONE_MODE = 5;     // Processor operation complete
   parameter 	 POWERON_MODE = 6;     // Processor initializing

   // Status conditions
   parameter 	 STAT_BUB = 3'h0;
   parameter 	 STAT_AOK = 3'h1;
   parameter 	 STAT_HLT = 3'h2;
   parameter 	 STAT_ADR = 3'h3;
   parameter 	 STAT_INS = 3'h4;
   parameter 	 STAT_PIP = 3'h5;

   // Control signals
   wire 	 running = (mode == RUN_MODE);
   wire 	 resetting = (mode == RESET_MODE);
   wire 	 downloading = (mode == DOWNLOAD_MODE);
   wire 	 uploading = (mode == UPLOAD_MODE);
   wire 	 getting_info = (mode == STATUS_MODE);
   wire 	 done = (mode == DONE_MODE);

   // Memory for up/down load of code & results
   memory #(code_size) udm(uploading, udaddr, odata,
                           downloading, udaddr, idata, clock);

   // Operational control
   always
     begin
	@(posedge clock)
	  begin
	     if (downloading)  // Downloading code
	       begin
		  if (udaddr < code_size-8)
		    udaddr <= udaddr + 8;
		  else 
		    begin
		       mode   <= RESET_MODE;
		       $display("Resetting");
		    end
	       end
	     if (resetting)
	       begin
		  cycle_count <= 0;
		  mode <= RUN_MODE;
		  $display("Running processor");
	       end
	     if (running)  // Running processor
	       begin
		  if ((stat == STAT_AOK || stat == STAT_BUB) && cycle_count < max_cycles)
		    cycle_count <= cycle_count + 1;
		  else begin
		     $display("Completed in %d cycles with exception status '%s'",
			      cycle_count,
			      stat == STAT_AOK ? "AOK" : 
			      stat == STAT_BUB ? "BUB" : 
			      stat == STAT_ADR ? "ADR" : 
			      stat == STAT_INS ? "INS" : 
			      stat == STAT_HLT ? "HLT" : 
			      stat == STAT_PIP ? "PIPE" : 
			      "Unknown");
		     mode <= STATUS_MODE;
		     udaddr <= 0;
		     $display("Uploading results");
		  end
	       end
	     if (getting_info) // Get registers and other values
	       begin
		  if (udaddr == 0)
		    begin
		       if (odata !== 0) $display("rax: 0x%h", odata);
		       udaddr <= udaddr + 8;
		    end
		  if (udaddr == 8)
		    begin
		       if (odata !== 0) $display("rcx: 0x%h", odata);
		       udaddr <= udaddr + 8;
		    end
		  if (udaddr == 16)
		    begin
		       if (odata !== 0) $display("rdx: 0x%h", odata);
		       udaddr <= udaddr + 8;
		    end
		  if (udaddr == 24)
		    begin
		       if (odata !== 0) $display("rbx: 0x%h", odata);
		       udaddr <= udaddr + 8;
		    end
		  if (udaddr == 32)
		    begin
		       if (odata !== 0) $display("rsp: 0x%h", odata);
		       udaddr <= udaddr + 8;
		    end
		  if (udaddr == 40)
		    begin
		       if (odata !== 0) $display("rbp: 0x%h", odata);
		       udaddr <= udaddr + 8;
		    end
		  if (udaddr == 48)
		    begin
		       if (odata !== 0) $display("rsi: 0x%h", odata);
		       udaddr <= udaddr + 8;
		    end
		  if (udaddr == 56)
		    begin
		       if (odata !== 0) $display("rdi: 0x%h", odata);
		       udaddr <= udaddr + 8;
		    end
		  if (udaddr == 64)
		    begin
		       if (odata !== 0) $display("r8: 0x%h", odata);
		       udaddr <= udaddr + 8;
		    end
		  if (udaddr == 72)
		    begin
		       if (odata !== 0) $display("r9: 0x%h", odata);
		       udaddr <= udaddr + 8;
		    end
		  if (udaddr == 80)
		    begin
		       if (odata !== 0) $display("r10: 0x%h", odata);
		       udaddr <= udaddr + 8;
		    end
		  if (udaddr == 88)
		    begin
		       if (odata !== 0) $display("r11: 0x%h", odata);
		       udaddr <= udaddr + 8;
		    end
		  if (udaddr == 96)
		    begin
		       if (odata !== 0) $display("r12: 0x%h", odata);
		       udaddr <= udaddr + 8;
		    end
		  if (udaddr == 104)
		    begin
		       if (odata !== 0) $display("r13: 0x%h", odata);
		       udaddr <= udaddr + 8;
		    end
		  if (udaddr == 112)
		    begin
		       if (odata !== 0) $display("r14: 0x%h", odata);
		       udaddr <= udaddr + 8;
		    end
		  if (udaddr == 120)
		    begin
		       $display("CC = Z=%b S=%b O=%b", odata[2], odata[1], odata[0]);
		       udaddr <= udaddr + 8;
		    end
		  if (udaddr == 128)
		    begin
		       $display("PC = 0x%h", odata);
		       udaddr <= udaddr + 8;
		    end
		  if (udaddr > 128)
		    begin
		       mode <= DONE_MODE;
		       $display("Operation complete");
		    end
	       end
	  end
     end
   initial
     begin
	// Get thing started, by idling in "power on mode" for a few cycles
	mode = POWERON_MODE;
	@(posedge clock);
	@(posedge clock);
	@(posedge clock);
	@(posedge clock);
	@(posedge clock);
	// Now start operation by downloading program.  The control logic takes over after this point
	mode <= DOWNLOAD_MODE;
	udaddr <= 0;
	$display("Starting Download");
     end
endmodule

module main;
   wire [63:0] max_cycle = 256;
   wire [ 2:0] mode;   // Signal operating mode to processor
   wire [63:0] udaddr; // Upload/download address
   wire [63:0] idata;  // Download data word
   wire [63:0] odata;  // Upload data word
   wire [ 2:0] stat;   // Exception status
   wire        clock;  // Clock input

   parameter   DONE_MODE = 5;     // Processor operation complete

   

   // Clock
   cgen c(clock);
   // Processor
   processor p(mode, udaddr, idata, odata, stat, clock);
   // Controller
   controller ct(mode, udaddr, idata, odata, stat, clock, max_cycle);

   // Initialization
   initial
     begin
	// The controller handles everything.  Main program just waits until completion.
	wait(mode == DONE_MODE);
	$finish;
     end
endmodule

// --------------------------------------------------------------------
// End of file "controller.v"
// --------------------------------------------------------------------
